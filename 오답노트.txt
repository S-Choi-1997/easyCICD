=====
오답노트 작성 규칙
=====

1. 순수 텍스트만 사용
   - 마크다운 문법 사용 금지 (**, `, ##, 이모지 등)
   - 코드 블록 사용 금지, 들여쓰기로만 표시
   - 목록 표시는 - 또는 숫자. 사용

2. 구조는 간결하게
   - 문제: 무슨 증상이 발생했는가
   - 원인: 왜 발생했는가  
   - 해결: 어떻게 고쳤는가
   - 교훈: 다시 안 겪으려면 무엇을 기억할 것인가

3. 설명은 핵심만
   - 불필요한 배경 설명 제거
   - 코드는 핵심 부분만
   - 프로세스 흐름은 간결하게 유지

4. 코드 표기
   - 파일 경로: agent/src/main.rs:252
   - 명령어: docker compose down
   - 변수/함수: synchronize_container_states()
   - 에러: "migration 2 was previously applied"

5. 제목 표기
   - 구분선: ===== (5자)
   - 문제 번호: 문제 X: 간결한 제목


=====
문제 1: SQLite DB 파일 생성 실패
=====

문제: error returned from database: (code: 14) unable to open database file
원인: SQLx 기본값으로는 DB 파일 자동 생성 안함
해결: SqliteConnectOptions::create_if_missing(true) 추가
파일: agent/src/db/queries.rs:12-14
교훈: SQLite 연결 시 create_if_missing 옵션 필수

=====
문제 2: DB 경로 충돌
=====

문제: /data/db/ 디렉토리와 /data/db.sqlite 파일명 충돌
원인: 동일 이름으로 디렉토리와 파일 동시 사용 불가
시도:
  - /data/db.sqlite → 실패 (기존 디렉토리와 충돌)
  - /data/db/easycicd.db → 실패 (구조 혼란)
해결: 전용 디렉토리 /data/easycicd/db.sqlite 생성
교훈: DB 파일은 전용 디렉토리 안에 배치

=====
문제 3: Axum 0.7 라우팅 문법 변경
=====

문제: Path segments must not start with `:`. For capture groups, use `{capture}`
원인: Axum 0.7에서 경로 파라미터 문법 변경
해결: :id → {id} 변경
파일: agent/src/api/projects.rs:20-21, agent/src/api/builds.rs:16
교훈: 메이저 버전 업그레이드 시 Breaking Changes 확인

=====
문제 4: Axum 0.7 정적 파일 서빙 변경
=====

문제: Nesting at the root is no longer supported
원인: Axum 0.7에서 루트 경로 nest_service 금지
해결: .nest_service("/", ...) → .fallback_service(...)
파일: agent/src/main.rs:71
교훈: Axum 0.7 라우팅 API 변경사항 확인

=====
문제 5: GLIBC 버전 불일치
=====

문제: version 'GLIBC_2.39' not found
원인: 빌드(Trixie)와 런타임(Bookworm) GLIBC 버전 차이
해결: 런타임 베이스 이미지를 debian:trixie-slim으로 변경
파일: agent/Dockerfile:29
교훈: 멀티스테이지 빌드 시 GLIBC 버전 통일

=====
문제 6: 정적 파일 경로 오류
=====

문제: ../frontend 참조 시 /frontend가 됨
원인: 작업 디렉토리 /app인데 상대 경로 계산 오류
해결: "../frontend" → "frontend"
파일: agent/src/main.rs:71
교훈: Docker 컨테이너 내 작업 디렉토리 기준 경로 확인

=====
문제 7: nginx daemon directive 중복
=====

문제: nginx: [emerg] "daemon" directive is duplicate, Runtime 컨테이너 계속 재시작
원인: nginx.conf에 "daemon off;" + runtime_command에도 "-g 'daemon off;'" 중복
해결: nginx.conf에만 유지, runtime_command에서 제거
파일:
  - agent/src/github/detector.rs:125 (Node.js Frontend)
  - agent/src/github/detector.rs:224 (Static Site)
  - agent/src/github/detector.rs:425
교훈: nginx 설정을 파일과 CLI 양쪽에서 중복 지정 금지

=====
문제 8: Docker 네트워크 - localhost 통신 실패
=====

문제 8-1: 헬스체크 실패

문제: Health check failed - error sending request for url (http://localhost:10001/health)
원인: Agent가 localhost:10001 호출 시 자기 자신 가리킨함
배경: Agent와 Runtime 컨테이너가 서로 다른 네트워크
시도:
  - 172.17.0.1 사용 → 실패 (bridge 네트워크, agent는 easycicd)
  - host 네트워크 모드 → 실패 (포트 바인딩 안됨)
해결:
  1. Runtime 컨테이너를 easycicd_easycicd 네트워크에 연결
  2. Gateway IP (172.19.0.1) 자동 감지
  3. 헬스체크에서 gateway_ip 사용
파일:
  - agent/src/docker/client.rs:60-72 (gateway IP 감지)
  - agent/src/docker/client.rs:293-304 (네트워크 연결)
  - agent/src/build/deployer.rs:226-227 (헬스체크 URL)

문제 8-2: 프록시 연결 실패

문제: Failed to proxy request for url (http://localhost:10001/)
원인: Reverse proxy에서 localhost:10001 호출 시 자기 자신 가리킴
해결:
  1. AppState에 gateway_ip 필드 추가
  2. main.rs에서 DockerClient 초기화 후 gateway_ip 추출
  3. 프록시 라우터에서 gateway_ip 사용
파일:
  - agent/src/state.rs:16 (gateway_ip 필드)
  - agent/src/main.rs:63-64 (DockerClient 초기화)
  - agent/src/proxy/router.rs:89-92 (gateway_ip 사용)

교훈: 컨테이너 간 통신은 localhost 아닌 gateway IP 사용

=====
문제 9: 모노레포 working_directory DB 누락
=====

문제: 
  - Gradle: "Directory '/app' does not contain a Gradle build"
  - npm: "ENOENT: no such file or directory, open '/app/package.json'"
  - path_filter="project1" 설정했으나 빌드는 /app에서 실행됨
원인:
  - INSERT 쿼리에 working_directory 컬럼 바인딩 누락
  - 모든 프로젝트 working_directory = NULL
  - 빌드 컨테이너는 항상 /app에서 실행
데이터 플로우:
  Frontend → API → DB (누락!) → Build Executor → Docker
해결:
  1. INSERT 쿼리에 working_directory 컬럼 추가
  2. VALUES에 ? 플레이스홀더 추가 (13개→14개)
  3. .bind(&project.working_directory) 추가
파일: agent/src/db/queries.rs:89-110
교훈: 새 필드 추가 시 전체 레이어 검증

=====
문제 10: 헬스체크 stale data
=====

문제: 새 컨테이너 정상 실행 중인데도 헬스체크 실패, active_slot 전환 안됨
원인:
  - deployer.rs의 deploy() 함수에서 project 변수는 함수 시작 시점 값
  - DB에 새 container_id 업데이트해도 project 변수는 old 값 유지
  - 헬스체크가 old container_id 체크하여 실패
해결:
  - perform_health_check에 container_id 직접 전달
  - project 객체에서 읽지 않고 실제 생성된 container_id 사용
파일: agent/src/build/deployer.rs:118-120, 252-310
교훈: In-memory 객체와 DB 상태 동기화 주의, 중요한 값은 직접 전달

=====
문제 11: 헬스체크 context path
=====

문제: Spring Boot context path (/api/spring) 사용 시 404
원인:
  - 헬스체크 URL: /actuator/health
  - 실제 URL: /api/spring/actuator/health
해결: HTTP 헬스체크 제거, Docker API로 컨테이너 상태 확인으로 변경
  - is_container_running() 사용
  - 10회 재시도, 2초 간격
파일: agent/src/build/deployer.rs:252-310
교훈: 언어/프레임워크 중립적 방식 선택, 복잡한 설정보다 단순한 해결책

=====
문제 12: 시스템 재시작 후 컨테이너 불일치
=====

문제: "Project 'xxx': Blue container abc123 not found, skipping cleanup"
원인:
  - Agent 컨테이너 재시작 시 Runtime 컨테이너들 삭제됨
  - DB에는 삭제된 container_id 저장
해결: 시작 시 컨테이너 상태 동기화
  - 모든 프로젝트의 blue/green 컨테이너 확인
  - 존재하지 않는 container_id는 DB에서 제거
파일: agent/src/main.rs:79-82, 163-200
교훈: 시스템 시작 시 일관성 검증 필요, DB와 실제 리소스 동기화

=====
문제 13: 타겟 슬롯 기존 컨테이너 존재
=====

문제: 타겟 슬롯에 기존 컨테이너 남아있어 포트 충돌
원인: 이전 배포 실패 시 컨테이너 남음
해결: 배포 전 타겟 슬롯 정리
  - 기존 컨테이너 확인 → 중지 → 제거
  - DB에서 container_id 제거
파일: agent/src/build/deployer.rs:57-83
블루-그린 3단계 보호:
  1. 프로젝트 생성: active_slot='Blue', container_ids=NULL
  2. 시스템 시작: 존재하지 않는 컨테이너 DB 정리
  3. 배포 전: 타겟 슬롯 기존 컨테이너 정리
교훈: Idempotent operations, 항상 깨끗한 상태에서 시작

=====
문제 14-20: 아키텍처 문제 (리팩토링 필요성)
=====

문제 14: AppState God Object - 모든 의존성 집중, 테스트 불가능
문제 15: 비즈니스 로직과 HTTP 핸들러 혼재
문제 16: 이벤트 발행 코드 분산
문제 17: Mock 주입 불가능한 구조
문제 18: 모듈 간 통신 로깅 부재
문제 19: DB 접근 분산
문제 20: API 명세 불일치

해결 방향:
  - Trait 기반 의존성 주입
  - Application Service 레이어 분리
  - EventBus trait, BoundaryLogger
  - Repository 패턴
  - OpenAPI 자동 생성

=====
문제 21: broadcast 채널 에러 미처리
=====

문제: WebSocket 브로드캐스팅 조용히 중단
원인: broadcast::Receiver::recv() Err 케이스 미처리
해결: match로 Ok/Err 명시적 처리, Err 시 에러 로그 및 종료
파일: agent/src/ws_broadcaster.rs:14
교훈: 모든 Result 명시적 처리, 특히 채널/스트림

=====
문제 22: 워크스페이스 경로 불일치
=====

문제: Git 정보 수집 시 빈 커밋 해시 반환
원인: API와 서비스에서 다른 경로 사용 (/workspace/projects vs /data/workspace)
해결: /data/workspace/{name}로 통일
파일: agent/src/api/projects.rs:163, agent/src/application/services/project_service.rs:112
교훈: 하드코딩 경로는 상수화

=====
문제 23: 순차 처리 Race Condition
=====

문제: 동일 프로젝트 순차 처리 보장 깨짐
원인: finish_processing() 직후 즉시 다음 빌드 시작
해결: finish_processing() 후 100ms 딜레이 추가
파일: agent/src/build/worker.rs:42
교훈: 상태 전환 후 작은 딜레이로 race condition 방지

=====
문제 24: Response 생성 unwrap() 남용
=====

문제: Body 구성 실패 시 panic, 프록시 크래시 위험
원인: Response::builder().body().unwrap() 10곳에서 사용
해결: error_response() 헬퍼 함수 추가
파일: agent/src/proxy/router.rs (82, 92, 103, 113, 127, 135, 196, 224, 240, 267)
교훈: unwrap() 대신 적절한 에러 처리, 특히 핵심 경로

=====
문제 25: Trait Scope 누락 - 대규모 컴파일 에러
=====

문제: 4개 에러 → 119개로 폭발
원인: Phase 5-6 리팩토링 후 trait 메서드 사용하는데 trait import 누락
핵심: Rust는 trait 메서드 사용 시 반드시 trait이 scope에 있어야 함
해결: 필요한 trait import 추가
예시:
  - use crate::application::events::event_bus::EventBus;
  - use crate::application::ports::repositories::{ProjectRepository, BuildRepository};
발생 위치: ws_broadcaster.rs, build/worker.rs, api/webhook.rs, api/projects.rs 등 10개 파일
교훈: trait 메서드 사용 시 반드시 trait import

=====
문제 26: api_exit() 타입 불일치
=====

문제: 80+ 개 type mismatch 에러
원인: api_exit() 시그니처가 u16 요구하는데 모든 핸들러에서 &str로 호출
해결: sed로 일괄 치환
  sed -i 's/api_exit(\(.*\), "\([0-9]\{3\}\)")/api_exit(\1, \2)/g' agent/src/api/*.rs
예시: "200" → 200
교훈: 공통 패턴은 sed로 일괄 처리

=====
문제 27: 타입 추론 실패
=====

문제: cannot infer type
원인: Repository trait의 제네릭 메서드 호출 시 타입 추론 불가
해결: 반환 타입 명시적 지정
예시:
  let project_opt: Option<crate::db::models::Project> = ctx.project_repo.get(project_id).await?;
  let project = project_opt.context(...)?;
파일: build/worker.rs (2곳), api/webhook.rs (1곳)
교훈: 제네릭 반환 타입은 명시적 annotation 필요

=====
문제 28: 중복 모듈 선언
=====

문제: file for module 'state' found at both "src/state.rs" and "src/state/mod.rs"
원인: Phase 5에서 state.rs를 state/ 디렉토리로 분리했으나 state.rs 파일 남음
해결: agent/src/state.rs 삭제
교훈: foo.rs 또는 foo/mod.rs 둘 중 하나만

=====
문제 29: hyper Body moved value
=====

문제: use of moved value: body
원인: proxy/router.rs에서 body를 두 번 사용 (move 후 재사용)
해결: clone 사용
  match response_builder.body(Full::new(body.clone())) {
    Ok(response) => Ok(response),
    Err(e) => Ok(Response::new(Full::new(body)))
  }
파일: agent/src/proxy/router.rs:257
교훈: 값 두 번 사용 시 clone 필요

=====
문제 30: tracing macro import 누락
=====

문제: cannot find macro 'error' in this scope
원인: main.rs에서 error! 매크로 사용했으나 import 안함
해결: use tracing::{info, error};
파일: agent/src/main.rs:116
교훈: 매크로도 명시적 import 필요

=====
문제 31: sqlx::migrate! 동기화
=====

문제: 마이그레이션 파일 삭제해도 컨테이너 재시작 반복, "duplicate column name" 에러
원인: sqlx::migrate!()가 컴파일 타임에 바이너리에 임베드
핵심:
  1. 컴파일 타임에 ./migrations 디렉토리 읽음
  2. 모든 .sql 파일을 바이너리에 임베드
  3. 런타임에는 임베드된 데이터 사용 (파일시스템 안 봄)
발생 시나리오:
  1. 003_deploy_logs.sql 작성 → 빌드 → 배포 → DB 적용
  2. 로컬에서 003_deploy_logs.sql 삭제
  3. 다시 배포 → Docker 이미지는 여전히 이전 빌드 (003 포함)
  4. 컨테이너 실행 → 임베드된 003 실행 시도 → "duplicate column name"
해결:
  1. 마이그레이션 파일 수정/삭제 후 반드시 재빌드 (./deploy.sh)
  2. 충돌 발생 시 DB 초기화
     docker-compose down
     sudo rm -rf /data/easycicd/db.sqlite*
     docker-compose up -d
교훈: 한번 배포된 마이그레이션은 수정 금지, 새 파일 추가

=====
문제 32: 빌드 실패 시 로그 404
=====

문제: Build #9, #10 실패했으나 status "Building"으로 남음, build-logs API 404
원인:
  1. BuildService에서 prepare_source() 단계에서 에러
  2. 로그 파일은 prepare_source() 이후에 생성
  3. 에러 시 로그 파일 미생성 → 404
  4. worker.rs에서 에러 발생 시 DB 상태 미업데이트
로그 플로우:
  Line 104: 로그 디렉토리 생성
  Line 107: prepare_source() 호출 ← 여기서 실패
  Line 113: 로그 파일 생성 ← 도달하지 못함
해결:
  1. worker.rs에서 에러 시 build_repo.finish(build_id, BuildStatus::Failed) 호출
  2. workspace 경로를 프로젝트 이름 → ID로 변경
교훈: 로그 파일 최대한 빨리 생성, 에러 처리에서 DB 상태 업데이트

=====
문제 33: Proxy 502 - 변수명 불일치
=====

문제: 502 Bad Gateway, "Backend request failed: error sending request for url (http://172.19.0.1:10002/)"
원인:
  - Phase 5-6 리팩토링 후 파라미터 변경: state → ctx
  - target_uri 생성할 때 변수명 오타: context.gateway_ip (존재 안함)
컴파일 에러:
  error[E0425]: cannot find value `context` in this scope
  --> src/proxy/router.rs:169:38
발견이 어려웠던 이유:
  - 로컬 cargo build 성공
  - Docker 빌드만 실패 (레이어 캐싱)
해결: context.gateway_ip → ctx.gateway_ip
파일: proxy/router.rs:169, 171
교훈: 리팩토링 시 변수명 일관성 체크, cargo build 2>&1 | grep "error\[E"

=====
문제 34: bollard 0.19 deprecated API
=====

문제: this function takes 0 arguments but 1 argument was supplied
원인: bollard 0.19에서 ListContainersOptions, RemoveContainerOptions deprecated
해결: #[allow(deprecated)] 추가
교훈: 크레이트 업데이트 시 CHANGELOG 확인

=====
문제 35: service_entry 인자 개수 불일치
=====

문제: this function takes 5 arguments but 4 arguments were supplied
원인: BoundaryLogger::service_entry 시그니처는 (trace_id, from, service, method, params)인데 from 누락
해결: from 파라미터 추가
  self.logger.service_entry(trace_id, "API", "ContainerService", "create_container", &req.name);
교훈: 기존 코드 참조하여 동일 패턴 적용

=====
문제 36: include_str! 삭제된 파일 참조
=====

문제: couldn't read src/db/../../migrations/002_settings.sql: No such file or directory
원인:
  - include_str!는 컴파일 타임에 파일 읽음
  - 마이그레이션 파일을 001_initial.sql로 통합 후 개별 파일 삭제
  - queries.rs의 migrate()가 여전히 삭제된 파일 참조
해결: migrate() 함수 비우고 deprecated 표시
  pub async fn migrate(&self) -> Result<(), sqlx::Error> {
    // NOTE: This function is deprecated. Use sqlx::migrate!() in main.rs instead.
    Ok(())
  }
교훈: include_str! 특성 이해 (컴파일 타임 임베딩)

=====
문제 37: Migration 버전 충돌
=====

문제: migration 2 was previously applied but is missing in the resolved migrations
원인:
  - 기존 DB에 002, 003 적용 기록 존재 (_sqlx_migrations 테이블)
  - migrations 폴더에서 해당 파일 삭제
해결: DB 파일 삭제 후 재생성
  sudo rm /data/easycicd/db.sqlite*
교훈: 마이그레이션 통합은 신중하게, 개발 환경에서만 DB 삭제

=====
문제 38: SQLite DB 파일 생성 권한
=====

문제: Database(Sqlite(SqliteError { code: 14, message: "unable to open database file" }))
원인: /data/easycicd/ 디렉토리 쓰기 권한 없음
해결:
  방법 1: sudo touch /data/easycicd/db.sqlite && sudo chmod 666 /data/easycicd/db.sqlite
  방법 2: sudo chmod 777 /data/easycicd/
교훈: Docker 볼륨 권한 주의, create_if_missing 한계 (디렉토리 쓰기 권한 필요)

=====
문제 39: 마이그레이션 파일 관리 복잡도
=====

문제: 개발 단계에서 마이그레이션 파일 수정 시 지속적 충돌 (문제 31, 37 반복)
원인: sqlx 마이그레이션 불변성 원칙이 개발에서 방해
해결: 단일 001_initial.sql로 통합
변경 사항:
  1. 001_initial.sql에 모든 스키마 통합
  2. 불필요한 파일 삭제 (002, 003)
  3. reset-db.sh 스크립트 작성
장점:
  - 스키마 수정 시 001 파일만 편집하고 ./reset-db.sh -y 실행
  - 마이그레이션 파일 1개로 관리
  - DB 초기화 10초 이내
교훈: 개발 단계는 단순함과 속도 우선, 001_initial.sql이 현재 스키마의 완전한 정의

=====
문제 40: DB 경로 혼동 및 create_if_missing 누락
=====

문제 1: "migration 2 was previously applied but is missing" 에러
  새로 빌드한 이미지로 컨테이너 시작 시 계속 재시작
원인:
  - 새 Docker 이미지에는 001_initial.sql만 포함
  - 기존 DB에 002, 003 적용 기록 존재
근본 원인 발견:
  - docker-compose.yml 볼륨 마운트: ./data:/data
  - DB 실제 위치: /home/choho97/easycicd/data/easycicd/db.sqlite (프로젝트 디렉토리)
  - 잘못 삭제한 경로: /data/easycicd/db.sqlite (시스템 루트)
해결: rm -f /home/choho97/easycicd/data/easycicd/db.sqlite*

문제 2: "unable to open database file" (code: 14)
원인: main.rs에서 create_if_missing(true) 누락
해결:
  use sqlx::sqlite::SqliteConnectOptions;
  use std::str::FromStr;
  let options = SqliteConnectOptions::from_str(database_url)?.create_if_missing(true);
  let pool = SqlitePool::connect_with(options).await?;

문제 3: Docker 캐시로 인한 코드 미반영
원인: docker compose restart는 기존 이미지 사용
해결: 
  cd agent && docker build -t choho97/lightweight-ci:latest .
  docker compose down && docker compose up -d

교훈:
  1. 볼륨 마운트 경로 정확히 파악 (./data:/data → 프로젝트의 ./data가 /data로 마운트)
  2. create_if_missing(true) 옵션 필수
  3. 코드 수정 후 반드시 재빌드 (restart는 이미지 재사용)

=====
문제 41: DB 초기화 후 고아 컨테이너 미정리
=====

문제: DB 초기화 후 Docker 컨테이너 남아있는데 Agent가 인식 못함
증상:
  - docker ps: container-test-nginx, container-httpbin-test 실행 중
  - API 조회: [] 빈 배열
  - UI에서 보이지 않고 제어 불가
원인: synchronize_container_states()가 DB 항목만 체크, Docker 컨테이너는 확인 안함
발생 시나리오:
  1. Container 기능으로 nginx, httpbin 생성 → DB 등록
  2. reset-db.sh 실행 → DB만 초기화 (Docker 컨테이너는 그대로)
  3. Agent 재시작 → DB에 정보 없음
  4. 컨테이너는 실행 중이지만 관리 불가능 → 고아 컨테이너
해결: Docker의 모든 컨테이너 확인하여 DB에 없으면 자동 삭제
  1. DB 독립 컨테이너 목록 가져오기
     let db_containers = context.container_repo.list().await?;
     let valid_container_names: HashSet = ...
  2. Docker의 모든 컨테이너 순회
     - 프로젝트 컨테이너 (project-{id}-{slot}): project_id가 DB에 없으면 삭제
     - 독립 컨테이너 (container-{name}): name이 DB에 없으면 삭제
파일: agent/src/main.rs:252-300
동작 확인:
  docker logs easycicd-agent | grep Cleaning
  → Cleaning up orphan standalone container: container-test-nginx (name 'test-nginx' not in DB)
핵심 원칙: DB = Source of Truth, 양방향 동기화 (DB→Docker + Docker→DB)
교훈: 상태 동기화는 DB와 실제 리소스 양방향 확인
