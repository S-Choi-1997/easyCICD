================================================================================
                    Lightweight CI/CD 최종 설계 문서
================================================================================

버전: 1.0
최종 수정: 2025-01-07

================================================================================
목차
================================================================================

1. 프로젝트 개요
2. 시스템 아키텍처
3. 핵심 컴포넌트
4. 도메인 및 포트 구조
5. 프로젝트 등록 및 설정
6. 빌드 및 배포 프로세스
7. 실시간 통신 (WebSocket)
8. 사용자 인터페이스
9. 기술 스택 및 디렉토리 구조
10. 보안 및 확장성
11. 개발 단계


================================================================================
1. 프로젝트 개요
================================================================================

1.1 목적
--------
- GitHub Webhook 기반 자동 빌드 및 배포 시스템
- Docker를 활용한 격리된 빌드 환경 제공
- Blue/Green 무중단 배포 지원
- 경량화된 단일 서버 솔루션


1.2 핵심 특징
-------------
- DOOD (Docker-outside-of-Docker) 아키텍처
- 프로젝트별 독립적인 빌드 큐 관리
- 범용 캐시 시스템으로 빌드 속도 최적화
- WebSocket 기반 실시간 로그 스트리밍
- 프로젝트 이름 기반 경로 라우팅
- 서브도메인 분리 (관리/서비스)


1.3 기술 스택
-------------
백엔드:
  - Rust: axum, tokio, bollard, sqlx, hyper, tokio-tungstenite
  - SQLite: 메타데이터 저장

프론트엔드:
  - 미정 (Setup 페이지 + Dashboard)
  - WebSocket 클라이언트

인프라:
  - Docker: 빌드 및 런타임 환경
  - Cloudflare Tunnel: 외부 접근


================================================================================
2. 시스템 아키텍처
================================================================================

2.1 전체 구조
-------------

[GitHub Push]
    ↓
[Cloudflare Tunnel]
    ↓ (ci.yourdomain.com)        ↓ (app.yourdomain.com)
    ↓                              ↓
[Rust Agent Container (DOOD)]     │
    ├─ API Server (3000)          │
    │  └─ WebSocket (/ws) ←───────┤ (대시보드 연결)
    │                              │
    └─ Reverse Proxy (8080) ←─────┘ (서비스 접근)
         ↓
[Docker Build Containers] → [Build Output]
         ↓
[Runtime Containers: Blue/Green]
    ├─ Blue:  9001, 9011, 9021...
    └─ Green: 9002, 9012, 9022...


2.2 배포 구조 (DOOD 방식)
--------------------------

[Host Machine]
    │
    ├─ Docker Daemon (호스트의 Docker 엔진)
    │
    ├─ /opt/lightweight-ci/data/
    │   ├─ cache/          # 전역 캐시 (모든 프로젝트 공유)
    │   │   ├─ gradle/
    │   │   ├─ npm/
    │   │   ├─ pip/
    │   │   └─ cargo/
    │   ├─ workspace/      # 프로젝트별 소스 코드
    │   │   ├─ my-backend/
    │   │   └─ shop-frontend/
    │   ├─ output/         # 빌드별 결과물
    │   │   ├─ build1/
    │   │   └─ build2/
    │   ├─ logs/           # 빌드 로그
    │   │   ├─ my-backend/
    │   │   │   ├─ 1.log
    │   │   │   └─ 2.log
    │   │   └─ shop-frontend/
    │   └─ db/             # SQLite 데이터베이스
    │       └─ ci.db
    │
    ├─ [Rust Agent Container]
    │      ├─ /var/run/docker.sock (마운트)
    │      ├─ API Server (포트 3000)
    │      │   ├─ HTTP REST API
    │      │   └─ WebSocket Server
    │      ├─ Reverse Proxy (포트 8080)
    │      └─ Build Queue Manager
    │
    ├─ [Build Container (임시)]
    │      - 빌드만 수행 후 즉시 삭제
    │      - 호스트의 볼륨 마운트 사용
    │
    └─ [Runtime Containers]
           - Project 1 Blue (9001): 실행 중 (v1.0)
           - Project 1 Green (9002): 대기 또는 새 버전
           - Project 2 Blue (9011): 실행 중 (v2.3)
           - Project 2 Green (9012): 대기 또는 새 버전


================================================================================
3. 핵심 컴포넌트
================================================================================

3.1 Rust Agent (오케스트레이터)
-------------------------------
역할:
  - GitHub Webhook 수신 및 Secret 검증
  - 프로젝트별 빌드 큐 관리
    ○ 동일 프로젝트: 순차 실행
    ○ 다른 프로젝트: 병렬 실행
  - Docker API 호출 (bollard 라이브러리)
  - 빌드 로그 수집 및 실시간 스트리밍
  - Blue/Green 리버스 프록시 운영
  - WebSocket 연결 관리 및 브로드캐스트

책임:
  - API 엔드포인트 제공
  - 변경 파일 분석 및 프로젝트 매칭
  - 빌드 작업 스케줄링
  - 컨테이너 생명주기 관리
  - 실시간 이벤트 브로드캐스트


3.2 Docker Build System
------------------------
격리된 빌드 환경:

docker run --rm \
  -v /data/workspace/my-backend:/app:ro \    # 소스 (읽기 전용)
  -v /data/cache/gradle:/root/.gradle \      # 전역 캐시
  -v /data/output/build42:/output \          # 결과물
  gradle:jdk17 \
  bash -c "cd /app && ./gradlew bootJar && cp build/libs/*.jar /output/"

캐시 전략:
  - 패키지 매니저별 전역 캐시 디렉토리 공유
  - 모든 Gradle 프로젝트 → /data/cache/gradle
  - 모든 npm 프로젝트 → /data/cache/npm
  - 버전별 캐시는 패키지 매니저가 자동 관리

장점:
  - 빌드 환경 완전 격리
  - 호스트 시스템 오염 없음
  - 다양한 언어/프레임워크 지원
  - 재현 가능한 빌드


3.3 Reverse Proxy (경로 기반 라우팅)
------------------------------------
구조:

사용자 요청: https://app.yourdomain.com/my-backend/api/users
    ↓
프록시 (8080): 경로 파싱 → "my-backend"
    ↓
DB 조회: Project "my-backend" → active_slot = Blue
    ↓
포트 결정: Blue → 9001
    ↓
프록시: http://localhost:9001/api/users
    ↓
Spring Boot 응답 → 사용자

구현:
  - Rust hyper 라이브러리로 리버스 프록시
  - 프로젝트 이름으로 라우팅 테이블 관리
  - DB에서 active_slot 동적 조회
  - 요청 시마다 슬롯 전환 반영


3.4 Health Check & Deployment
------------------------------
배포 프로세스:

1. 빌드 성공 → /output/build42/app.jar 생성

2. Green 슬롯으로 새 런타임 컨테이너 시작:
   docker run -d \
     -v /data/output/build42:/app:ro \
     -p 9002:8080 \
     eclipse-temurin:17-jre \
     java -jar /app/app.jar

3. Health Check 시도:
   - 타임아웃: 30초
   - 재시도 간격: 5초
   - 최대 시도: 10회
   - Spring Boot: GET http://localhost:9002/actuator/health
   - React: GET http://localhost:9002/ (200 응답)
   - WebSocket으로 진행 상황 실시간 전송

4. 성공 시:
   - DB에서 active_slot 업데이트 (Blue → Green)
   - 이전 Blue 컨테이너 종료 및 삭제
   - WebSocket으로 배포 완료 알림

5. 실패 시:
   - Green 컨테이너 종료 및 삭제 (롤백)
   - Blue 유지 (무중단 보장)
   - 빌드 상태를 Failed로 표시
   - WebSocket으로 실패 알림


3.5 WebSocket Server
---------------------
역할:
  - 대시보드와 양방향 실시간 통신
  - 빌드 상태 변경 브로드캐스트
  - 로그 라인 스트리밍
  - Health Check 진행 상황 전송
  - 배포 완료/실패 알림

메시지 타입:
  - build_status: 빌드 상태 변경
  - log: 실시간 로그 라인
  - deployment: 배포 완료
  - health_check: Health Check 진행
  - container_status: 컨테이너 상태 변경
  - error: 에러 발생


================================================================================
4. 도메인 및 포트 구조
================================================================================

4.1 서브도메인 분리
-------------------

[관리 대시보드]
  https://ci.yourdomain.com
    ↓
  Cloudflare Tunnel → localhost:3000 (Rust API + WebSocket)

[실제 서비스]
  https://app.yourdomain.com
    ↓
  Cloudflare Tunnel → localhost:8080 (Rust Reverse Proxy)


4.2 프로젝트별 경로 라우팅
--------------------------

사용자가 프로젝트 등록 시 이름 지정:
  - "my-backend"
  - "shop-frontend"
  - "admin-api"

접속 URL:
  https://app.yourdomain.com/my-backend/
  https://app.yourdomain.com/shop-frontend/
  https://app.yourdomain.com/admin-api/

경로 매칭:
  /{project_name}/** → 해당 프로젝트의 활성 슬롯으로 프록시


4.3 포트 할당 전략
------------------

각 프로젝트마다 Blue/Green 2개 포트 자동 할당:

규칙: base_port + (project_id * 10) + slot_offset
  - base_port: 9000
  - slot_offset: Blue=1, Green=2

예시:
  Project 1 ("my-backend"):
    - Blue:  9001
    - Green: 9002

  Project 2 ("shop-frontend"):
    - Blue:  9011
    - Green: 9012

  Project 3 ("admin-api"):
    - Blue:  9021
    - Green: 9022

장점:
  - 포트 충돌 방지
  - 프로젝트 ID만으로 포트 계산 가능
  - 최대 9999개 프로젝트 지원


================================================================================
5. 프로젝트 등록 및 설정
================================================================================

5.1 프로젝트 생성 플로우
------------------------

[Setup Page - https://ci.yourdomain.com/setup]

1. GitHub 레포지토리 선택
   - OAuth로 레포 목록 가져오기
   - "username/my-spring-boot-app" 선택

2. 프로젝트 이름 입력
   - 입력: "my-backend"
   - 검증: 알파벳, 숫자, 하이픈만 허용 (^[a-z0-9-]+$)
   - URL 프리뷰: https://app.yourdomain.com/my-backend/

3. 경로 필터 (선택적)
   - 모노레포인 경우: "backend/**"
   - 전체 레포: "**" (기본값)

4. 브랜치 선택
   - "main", "master", "develop" 등

5. 빌드 설정
   - 빌드 이미지: gradle:jdk17
   - 캐시 타입: gradle
   - 빌드 명령:
     ```bash
     ./gradlew clean bootJar && \
     cp build/libs/*.jar /output/app.jar
     ```

6. 배포 설정
   - 런타임 이미지: eclipse-temurin:17-jre
   - 시작 명령: java -jar /app/app.jar
   - Health Check URL: /actuator/health

7. 포트 자동 할당
   - Blue: 9001 (자동)
   - Green: 9002 (자동)
   - 공개 URL: https://app.yourdomain.com/my-backend/


5.2 프로젝트 설정 파일 예시
---------------------------

Spring Boot 프로젝트:
```toml
[project]
name = "my-backend"
repo = "username/my-spring-boot-app"
path_filter = "backend/**"
branch = "main"

[build]
image = "gradle:jdk17"
cache_type = "gradle"
command = """
cd /app && \
./gradlew clean bootJar && \
cp build/libs/*.jar /output/app.jar
"""

[deploy]
image = "eclipse-temurin:17-jre"
command = "java -jar /app/app.jar"
health_check = "/actuator/health"
```

React 프로젝트:
```toml
[project]
name = "shop-frontend"
repo = "username/shop-react-app"
path_filter = "**"
branch = "main"

[build]
image = "node:20"
cache_type = "npm"
command = """
cd /app && \
npm ci && \
npm run build && \
cp -r dist /output/
"""

[deploy]
image = "nginx:alpine"
command = "nginx -g 'daemon off;'"
health_check = "/"
```


5.3 데이터 구조
---------------

```rust
struct Project {
    id: i64,

    // 프로젝트 식별
    name: String,              // "my-backend" (URL 경로)
    repo: String,              // "username/repo"
    path_filter: String,       // "backend/**"
    branch: String,            // "main"

    // 빌드 설정
    build_image: String,       // "gradle:jdk17"
    build_command: String,     // "./gradlew bootJar && ..."
    cache_type: String,        // "gradle" | "npm" | "pip" | "cargo"

    // 배포 설정
    runtime_image: String,     // "eclipse-temurin:17-jre"
    runtime_command: String,   // "java -jar /app/app.jar"
    health_check_url: String,  // "/actuator/health"

    // 포트 할당 (자동)
    blue_port: u16,            // 9001
    green_port: u16,           // 9002
    active_slot: Slot,         // Blue | Green

    // 컨테이너 ID (현재 실행 중)
    blue_container_id: Option<String>,
    green_container_id: Option<String>,

    created_at: DateTime,
    updated_at: DateTime,
}

enum Slot {
    Blue,
    Green,
}

struct Build {
    id: i64,
    project_id: i64,
    build_number: i64,         // 프로젝트별 증가 번호
    commit_hash: String,       // Git 커밋 해시
    status: BuildStatus,       // 현재 상태
    log_path: String,          // 로그 파일 경로
    started_at: DateTime,
    finished_at: Option<DateTime>,
}

enum BuildStatus {
    Queued,     // 큐 대기중
    Building,   // 빌드 진행중
    Deploying,  // 컨테이너 시작 + Health Check
    Success,    // 배포 완료
    Failed,     // 실패
}
```


================================================================================
6. 빌드 및 배포 프로세스
================================================================================

6.1 전체 흐름
-------------

[1. Webhook 수신]
   POST /webhook/github
   - Secret 검증 (HMAC-SHA256)
   - 변경 파일 분석 (commits[].modified/added/removed)
   - 프로젝트 매칭 (path_filter, branch)

[2. 큐 추가]
   - 프로젝트별 큐에 작업 추가
   - Build 레코드 생성 (status: Queued)
   - WebSocket 브로드캐스트: build_status (Queued)

[3. 소스 준비]
   cd /data/workspace/my-backend
   git pull origin main

[4. 빌드 실행]
   - 상태 업데이트: Queued → Building
   - WebSocket 브로드캐스트: build_status (Building)
   - Build ID 생성 (#42)
   - 로그 파일 생성 (/data/logs/my-backend/42.log)
   - Docker 빌드 컨테이너 실행
   - stdout/stderr → 로그 파일 + WebSocket 스트리밍

[5. 배포]
   - 상태 업데이트: Building → Deploying
   - WebSocket 브로드캐스트: build_status (Deploying)
   - 결과물 확인 (/data/output/build42/app.jar)
   - Green 슬롯에 런타임 컨테이너 시작
   - Health Check 대기 (WebSocket으로 진행률 전송)

[6. 프록시 스위칭]
   - Health Check 성공
   - DB 업데이트: active_slot = Green
   - 이전 Blue 컨테이너 종료
   - 상태 업데이트: Deploying → Success
   - WebSocket 브로드캐스트: deployment (Success)


6.2 빌드 상태 전이
------------------

Queued (대기중)
   ↓ (큐에서 꺼내짐)
Building (빌드 진행중)
   ↓ (빌드 성공)
Deploying (컨테이너 시작 + Health Check)
   ↓
Success (배포 완료) or Failed (실패)


6.3 에러 처리
-------------

빌드 실패:
  - 빌드 컨테이너 exit code != 0
  - 상태: Building → Failed
  - WebSocket: build_status (Failed)
  - 이전 버전 유지 (무중단)

배포 실패:
  - Health Check 타임아웃/실패
  - 상태: Deploying → Failed
  - Green 컨테이너 종료 (롤백)
  - Blue 유지 (무중단)
  - WebSocket: deployment (Failed)


================================================================================
7. 실시간 통신 (WebSocket)
================================================================================

7.1 WebSocket 엔드포인트
-------------------------

연결: wss://ci.yourdomain.com/ws

용도:
  - 빌드 상태 실시간 업데이트
  - 로그 스트리밍
  - 배포 진행 상황
  - Health Check 진행률
  - 컨테이너 상태 변경


7.2 메시지 프로토콜
-------------------

클라이언트 → 서버:

구독 요청:
{
  "type": "subscribe",
  "target": "build",
  "build_id": 42
}

{
  "type": "subscribe",
  "target": "project",
  "project_id": 1
}

{
  "type": "subscribe",
  "target": "global"
}

구독 해제:
{
  "type": "unsubscribe",
  "target": "build",
  "build_id": 42
}


서버 → 클라이언트:

빌드 상태 변경:
{
  "type": "build_status",
  "build_id": 42,
  "project_id": 1,
  "status": "Building",
  "timestamp": "2025-01-07T12:34:56Z"
}

실시간 로그:
{
  "type": "log",
  "build_id": 42,
  "line": "[INFO] Starting build...",
  "line_number": 123,
  "timestamp": "2025-01-07T12:34:57Z"
}

배포 완료:
{
  "type": "deployment",
  "project_id": 1,
  "project_name": "my-backend",
  "build_id": 42,
  "status": "Success",
  "slot": "Green",
  "url": "https://app.yourdomain.com/my-backend/",
  "timestamp": "2025-01-07T12:35:30Z"
}

Health Check 진행:
{
  "type": "health_check",
  "project_id": 1,
  "build_id": 42,
  "attempt": 3,
  "max_attempts": 10,
  "status": "Checking",
  "url": "http://localhost:9002/actuator/health",
  "timestamp": "2025-01-07T12:35:15Z"
}

컨테이너 상태:
{
  "type": "container_status",
  "project_id": 1,
  "container_id": "abc123",
  "slot": "Blue",
  "status": "Running",
  "timestamp": "2025-01-07T12:35:00Z"
}


7.3 브로드캐스트 구조
---------------------

```rust
struct WsConnections {
    // build_id -> Vec<WebSocket 연결>
    build_subscribers: HashMap<i64, Vec<Sender>>,

    // project_id -> Vec<WebSocket 연결>
    project_subscribers: HashMap<i64, Vec<Sender>>,

    // 전체 브로드캐스트
    global_subscribers: Vec<Sender>,
}

// 이벤트 발행
async fn on_build_status_changed(build_id: i64, status: BuildStatus) {
    let message = json!({
        "type": "build_status",
        "build_id": build_id,
        "status": status,
    });

    // 해당 빌드 구독자
    ws_connections.broadcast_to_build(build_id, message.clone()).await;

    // 전체 구독자
    ws_connections.broadcast_global(message).await;
}
```


================================================================================
8. 사용자 인터페이스
================================================================================

8.1 대시보드 페이지 (/)
-----------------------

URL: https://ci.yourdomain.com/

레이아웃:
┌─────────────────────────────────────────────────┐
│ Lightweight CI/CD                [Setup] [Logout]│
├─────────────────────────────────────────────────┤
│                                                 │
│ Projects                                        │
│                                                 │
│ ┌─────────────────────────────────────────┐   │
│ │ my-backend                    ● Running │   │
│ │ https://app.yourdomain.com/my-backend/  │   │
│ │                                           │   │
│ │ Latest Build: #42 (Success) 2m ago       │   │
│ │ Active Slot: Blue (v1.0.5)               │   │
│ │                                           │   │
│ │ [View Logs] [Trigger Build] [Settings]   │   │
│ └─────────────────────────────────────────┘   │
│                                                 │
│ ┌─────────────────────────────────────────┐   │
│ │ shop-frontend              ⚡ Deploying │   │
│ │ https://app.yourdomain.com/shop-frontend/│  │
│ │                                           │   │
│ │ Build #28 → Deploying to Green           │   │
│ │ Health Check: 3/10 attempts...           │   │
│ │                                           │   │
│ │ ┌─────────────────────────────────────┐ │   │
│ │ │ [INFO] Starting application...       │ │   │
│ │ │ [INFO] Tomcat started on port 8080   │ │   │
│ │ │ [INFO] Health check endpoint ready   │ │   │
│ │ │ ▋ (실시간 스트리밍)                  │ │   │
│ │ └─────────────────────────────────────┘ │   │
│ └─────────────────────────────────────────┘   │
│                                                 │
└─────────────────────────────────────────────────┘

기능:
  - 프로젝트 목록 표시
  - 실시간 상태 업데이트 (WebSocket)
  - 최신 빌드 정보
  - 활성 슬롯 표시
  - 로그 실시간 스트리밍
  - 수동 빌드 트리거


8.2 빌드 상세 페이지 (/builds/:id)
----------------------------------

URL: https://ci.yourdomain.com/builds/42

레이아웃:
┌─────────────────────────────────────────────────┐
│ Build #42 - my-backend                          │
├─────────────────────────────────────────────────┤
│                                                 │
│ Status: Success ✓                               │
│ Commit: abc1234 "Add user API"                  │
│ Started: 2025-01-07 12:34:56                    │
│ Duration: 2m 34s                                │
│ Deployed to: Green → Blue (switched)            │
│                                                 │
│ ┌─────────────────────────────────────────┐   │
│ │ Build Logs                               │   │
│ │ ─────────────────────────────────────── │   │
│ │ [12:34:56] Starting build...             │   │
│ │ [12:35:12] Downloading dependencies...   │   │
│ │ [12:36:45] Compiling...                  │   │
│ │ [12:37:20] Build successful ✓            │   │
│ │ [12:37:21] Starting deployment...        │   │
│ │ [12:37:30] Health check 1/10... OK       │   │
│ │ [12:37:35] Health check 2/10... OK       │   │
│ │ [12:37:40] Deployment complete ✓         │   │
│ └─────────────────────────────────────────┘   │
│                                                 │
│ [Rebuild] [View Project]                        │
│                                                 │
└─────────────────────────────────────────────────┘


8.3 Setup 페이지 (/setup)
--------------------------

URL: https://ci.yourdomain.com/setup

기능:
  - GitHub OAuth 연결
  - 레포지토리 선택
  - 프로젝트 설정 입력
  - URL 프리뷰
  - 설정 저장


================================================================================
9. 기술 스택 및 디렉토리 구조
================================================================================

9.1 Rust 의존성 (Cargo.toml)
-----------------------------

```toml
[dependencies]
# Web Framework
axum = "0.7"
tokio = { version = "1", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors"] }

# WebSocket
tokio-tungstenite = "0.21"

# Reverse Proxy
hyper = "1.0"
reqwest = "0.11"

# Docker API
bollard = "0.16"

# Database
sqlx = { version = "0.7", features = ["sqlite", "runtime-tokio"] }

# 직렬화
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# 기타
anyhow = "1"
thiserror = "1"
chrono = "0.4"
```


9.2 디렉토리 구조
-----------------

```
/opt/lightweight-ci/
├── agent/                      # Rust 소스 코드
│   ├── src/
│   │   ├── main.rs             # 진입점
│   │   ├── api/
│   │   │   ├── mod.rs
│   │   │   ├── projects.rs     # 프로젝트 CRUD
│   │   │   ├── builds.rs       # 빌드 조회
│   │   │   ├── webhook.rs      # GitHub Webhook
│   │   │   └── ws.rs           # WebSocket 핸들러
│   │   ├── build/
│   │   │   ├── mod.rs
│   │   │   ├── queue.rs        # 빌드 큐 관리
│   │   │   ├── executor.rs     # 빌드 실행
│   │   │   └── deployer.rs     # 배포 로직
│   │   ├── proxy/
│   │   │   ├── mod.rs
│   │   │   └── router.rs       # Reverse Proxy
│   │   ├── docker/
│   │   │   ├── mod.rs
│   │   │   └── client.rs       # bollard 래퍼
│   │   ├── db/
│   │   │   ├── mod.rs
│   │   │   ├── models.rs       # 데이터 구조
│   │   │   └── queries.rs      # SQL 쿼리
│   │   ├── events.rs           # 이벤트 버스
│   │   └── state.rs            # 공유 상태
│   ├── migrations/             # SQLite 마이그레이션
│   │   └── 001_initial.sql
│   ├── Cargo.toml
│   └── Dockerfile
├── data/
│   ├── cache/
│   │   ├── gradle/
│   │   ├── npm/
│   │   ├── pip/
│   │   └── cargo/
│   ├── workspace/
│   │   ├── my-backend/
│   │   └── shop-frontend/
│   ├── output/
│   │   ├── build1/
│   │   └── build2/
│   ├── logs/
│   │   ├── my-backend/
│   │   └── shop-frontend/
│   └── db/
│       └── ci.db
├── docker-compose.yml
└── README.md
```


9.3 main.rs 구조
----------------

```rust
#[tokio::main]
async fn main() -> Result<()> {
    // 1. 초기화
    let db = Database::connect("sqlite:///data/db/ci.db").await?;
    db.migrate().await?;

    let docker = DockerClient::new()?;

    let (event_tx, _) = tokio::sync::broadcast::channel(100);

    let state = Arc::new(AppState {
        db,
        docker,
        build_queue: BuildQueue::new(),
        ws_connections: WsConnections::new(),
        event_bus: event_tx,
    });

    // 2. API Server (포트 3000)
    let api_app = Router::new()
        // 웹 UI
        .route("/", get(dashboard_page))
        .route("/setup", get(setup_page))
        .route("/builds/:id", get(build_detail_page))

        // WebSocket
        .route("/ws", get(ws_handler))

        // Webhook
        .route("/webhook/github", post(github_webhook))

        // REST API
        .nest("/api", api_routes())

        .with_state(state.clone());

    let api_listener = TcpListener::bind("0.0.0.0:3000").await?;
    let api_server = axum::serve(api_listener, api_app);

    // 3. Reverse Proxy (포트 8080)
    let proxy_service = make_service_fn(move |_conn| {
        let state = state.clone();
        async move {
            Ok::<_, Infallible>(service_fn(move |req| {
                proxy_handler(req, state.clone())
            }))
        }
    });

    let proxy_addr = SocketAddr::from(([0, 0, 0, 0], 8080));
    let proxy_server = Server::bind(&proxy_addr).serve(proxy_service);

    // 4. 빌드 큐 워커 (백그라운드)
    let build_worker = tokio::spawn({
        let state = state.clone();
        async move {
            run_build_queue(state).await
        }
    });

    // 5. 이벤트 → WebSocket 브로드캐스터
    let ws_broadcaster = tokio::spawn({
        let state = state.clone();
        async move {
            run_ws_broadcaster(state).await
        }
    });

    // 6. 모두 동시 실행
    tokio::select! {
        _ = api_server => {},
        _ = proxy_server => {},
        _ = build_worker => {},
        _ = ws_broadcaster => {},
    }

    Ok(())
}
```


9.4 Docker Compose 구성
------------------------

```yaml
services:
  agent:
    build: ./agent
    container_name: lightweight-ci
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock  # DOOD
      - ./data:/data                                 # 모든 데이터
    ports:
      - "3000:3000"    # API + Web UI + WebSocket
      - "8080:8080"    # Reverse Proxy
    environment:
      - DATABASE_URL=sqlite:///data/db/ci.db
      - GITHUB_WEBHOOK_SECRET=${GITHUB_WEBHOOK_SECRET}
    restart: unless-stopped

# 배포된 컨테이너는 agent가 동적으로 생성/관리
```


================================================================================
10. 보안 및 확장성
================================================================================

10.1 보안 고려사항
------------------

Webhook 보안:
  - GitHub Secret을 사용한 HMAC-SHA256 서명 검증
  - IP 화이트리스트 (GitHub IP 범위)
  - 타임스탬프 검증 (Replay Attack 방지)

Docker 권한:
  - DOOD 방식으로 호스트 Docker 소켓 접근
  - 빌드 컨테이너는 제한된 권한으로 실행
  - 네트워크 격리 (빌드 컨테이너는 외부 접근 제한)

데이터 보호:
  - SQLite 파일 권한 관리 (600)
  - 민감한 환경 변수는 암호화 저장 (향후)
  - 로그 파일 접근 제한

대시보드 보안:
  - 현재: 내부 네트워크 전용
  - 향후: GitHub OAuth 인증
  - 세션 관리


10.2 확장 가능성
----------------

현재 버전 (v1.0):
  - 단일 서버 배포
  - SQLite 데이터베이스
  - 로컬 파일 시스템 캐시

향후 확장 고려:
  - 멀티 노드 지원 (분산 빌드)
  - PostgreSQL/MySQL 지원
  - S3 호환 스토리지 연동
  - 슬랙/디스코드 알림
  - 빌드 우선순위 관리
  - 리소스 사용량 모니터링
  - 빌드 아티팩트 버전 관리
  - 롤백 기능


================================================================================
11. 개발 단계
================================================================================

Phase 1: 기본 인프라 (2주)
  - Rust Agent 기본 구조
  - Docker API 연동 (bollard)
  - SQLite 스키마 설계 및 마이그레이션
  - Webhook 수신 및 검증

Phase 2: 빌드 시스템 (3주)
  - 빌드 큐 관리
  - Docker 컨테이너 실행
  - 로그 수집 및 저장
  - 캐시 시스템 구현
  - Git 소스 관리

Phase 3: 배포 시스템 (3주)
  - 런타임 컨테이너 관리
  - Health Check 구현
  - Blue/Green 전환 로직
  - 리버스 프록시 구현
  - 에러 처리 및 롤백

Phase 4: 실시간 통신 (2주)
  - WebSocket 서버 구현
  - 이벤트 버스 구축
  - 로그 스트리밍
  - 상태 브로드캐스트

Phase 5: Web UI (4주)
  - Setup 페이지 (프로젝트 설정)
  - Dashboard (빌드 히스토리)
  - 빌드 상세 페이지
  - WebSocket 클라이언트 연동
  - 실시간 로그 표시

Phase 6: 테스트 및 배포 (2주)
  - 통합 테스트
  - 부하 테스트
  - 문서화
  - Docker Compose 패키징
  - 배포 가이드 작성


================================================================================
문서 끝
================================================================================

관련 문서:
  - API_통신_명세서.txt: 상세한 API 및 통신 프로토콜 명세
  - README.txt: 문서 구조 및 시작 가이드

================================================================================
